function run(argv) {
  const Mail = Application("Mail");
  Mail.includeStandardAdditions = true;
  const SENTINEL = "__KEEP__";

  // Check if Mail.app is running
  if (!Mail.running()) {
    return JSON.stringify({
      success: false,
      error: "Mail.app is not running.",
      errorCode: "MAIL_APP_NOT_RUNNING",
    });
  }

  // Collect logs instead of using console.log
  const logs = [];
  function log(message) {
    logs.push(message);
  }

  // Parse arguments
  // argv[0]: outgoingId
  // argv[1]: newSubject
  // argv[2]: ignoredContent
  // argv[3]: toRecipientsJson
  // argv[4]: ccRecipientsJson
  // argv[5]: bccRecipientsJson
  // argv[6]: newSender
  // argv[7]: originalMessageId
  // argv[8]: originalAccountName
  // argv[9]: originalMailboxPathJson

  const outgoingId = argv[0] ? parseInt(argv[0]) : 0;
  const newSubject = argv[1] || "";
  const toRecipientsJson = argv[3] || "";
  const ccRecipientsJson = argv[4] || "";
  const bccRecipientsJson = argv[5] || "";
  const newSender = argv[6] || "";
  const originalMessageId = argv[7] ? parseInt(argv[7]) : 0;
  const originalAccountName = argv[8] || "";
  const originalMailboxPathJson = argv[9] || "";

  if (!outgoingId || outgoingId < 1) {
    return JSON.stringify({
      success: false,
      error: "Outgoing message ID is required",
    });
  }

  if (!originalMessageId || !originalAccountName || !originalMailboxPathJson) {
    return JSON.stringify({
      success: false,
      error: "Original message metadata is required for replace_reply_draft",
    });
  }

  try {
    // 1. Find the old draft to capture current state and then delete
    const allOutgoing = Mail.outgoingMessages();
    let oldMessage = null;
    for (let i = 0; i < allOutgoing.length; i++) {
      if (allOutgoing[i].id() === outgoingId) {
        oldMessage = allOutgoing[i];
        break;
      }
    }

    if (!oldMessage) {
      return JSON.stringify({
        success: false,
        error: "Existing draft with ID " + outgoingId + " not found.",
      });
    }

    // Capture existing properties to support __KEEP__ sentinel (null in Go)
    const oldSubject = oldMessage.subject();
    const oldSender = oldMessage.sender();

    const getAddresses = (collection) => {
      const addresses = [];
      try {
        const items = collection();
        for (let i = 0; i < items.length; i++) {
          addresses.push(items[i].address());
        }
      } catch (e) {
        log("Error reading recipients: " + e.toString());
      }
      return addresses;
    };

    const oldTo = getAddresses(oldMessage.toRecipients);
    const oldCc = getAddresses(oldMessage.ccRecipients);
    const oldBcc = getAddresses(oldMessage.bccRecipients);

    // 2. Find the original message to re-reply to
    const targetAccount = Mail.accounts[originalAccountName];
    const mailboxPath = JSON.parse(originalMailboxPathJson);
    let container = targetAccount;
    for (let i = 0; i < mailboxPath.length; i++) {
      container = container.mailboxes[mailboxPath[i]];
    }
    const matches = container.messages.whose({ id: originalMessageId })();
    if (matches.length === 0) {
      return JSON.stringify({
        success: false,
        error: "Original message not found. Cannot re-create reply.",
      });
    }
    const originalMsg = matches[0];

    // 3. Create fresh reply
    log("Creating fresh reply to original message...");
    const newMsg = originalMsg.reply({
      openingWindow: true,
      replyToAll: false,
    });

    // 4. Apply properties
    // Subject
    if (newSubject === SENTINEL) {
      newMsg.subject = oldSubject;
    } else {
      newMsg.subject = newSubject;
    }

    // Sender
    if (newSender === SENTINEL) {
      newMsg.sender = oldSender;
    } else if (newSender) {
      newMsg.sender = newSender;
    }

    // Recipients
    function updateRecipients(targetCollection, json, fallback) {
      // Clear recipients generated by originalMsg.reply()
      const current = targetCollection();
      for (let i = current.length - 1; i >= 0; i--) {
        current[i].delete();
      }

      let addrs = [];
      if (json === SENTINEL) {
        addrs = fallback;
      } else if (json && json !== "") {
        try {
          addrs = JSON.parse(json);
        } catch (e) {
          log("Error parsing recipients JSON: " + e.toString());
        }
      }

      addrs.forEach((addr) => {
        targetCollection.push(Mail.Recipient({ address: addr }));
      });
    }

    updateRecipients(newMsg.toRecipients, toRecipientsJson, oldTo);
    updateRecipients(newMsg.ccRecipients, ccRecipientsJson, oldCc);
    updateRecipients(newMsg.bccRecipients, bccRecipientsJson, oldBcc);

    newMsg.save();

    // 5. Delete old draft
    try {
      Mail.delete(oldMessage);
      log("Deleted old draft ID: " + outgoingId);
    } catch (e) {
      log("Warning: Could not delete old draft: " + e.toString());
    }

    Mail.activate();

    return JSON.stringify({
      success: true,
      data: {
        outgoing_id: newMsg.id(),
        subject: newMsg.subject(),
        message:
          "Reply draft re-created with updated properties. Window ready for paste.",
      },
      logs: logs.join("\n"),
    });
  } catch (e) {
    return JSON.stringify({
      success: false,
      error: "Failed to replace reply draft: " + e.toString(),
      logs: logs.join("\n"),
    });
  }
}
